---
layout: post
title: "笔记 - 知识点笔记-22年5月"
subtitle: ''
author: "ZolHo"
header-style: text
tags:
  - 学习记录
---

- 左右手坐标系下的默认旋转方向原来是不同的？？左手系顺时针，右手逆时针。(US入门精要4.2.5节)
- 半兰伯特模型：兰伯特模型中的点乘结果偏移+0.5，让非光线直射处也亮
- Schlick菲涅尔近似等式：$F_{schlick}(\bold{v,n})=F_0+(1-F_0)(1-\bold{v}\cdot \bold{n})^5$
- Empricial菲涅尔近似等式：$F_{Empricial}(\bold{v,n}=\max(0,\min(1,bias+scale\times (1-\bold{v}\cdot \bold{n})^{power})))$
  
### 法线变换

- 法线变换需要用变换矩阵的**逆转置矩阵**做变换，推导过程如下：![法线变换推导](/img/note/2022-05-03-15-52-00.png)

### 法线贴图

- 模型空间法线贴图优点：
  - 直观，计算简单
  - 边界突变少，边界处可通过插值平滑变化（*待加深理解*）
- 切线空间法线贴图优点：
  - 可换给其他模型使用
  - **可实现UV动画**
  - 纹理对于一个模型内也可重用
  - 可压缩，省略Z坐标

### 其他纹理

- `渐变纹理`，我的理解是将漫反射光照结果映射到我们自定义的纹理上
- `遮罩纹理`，单纯的遮罩纹理就是用于计算时mask其他纹理的某些部分，避免它们加入到计算中

### Bloom效果（后处理）

- 以某个阈值提取出画面中亮的部分做一次模糊，然后与原图混合

### 运动模糊

- 累计缓存：多张图像结果混合（在一帧渲染多次场景）
- 速度缓存：保存之前的渲染结果混合
- 速度映射图：用上一帧的VP矩阵对这一帧的顶点做变换，与本次变换结果做插值即可得到速度映射图。然后用速度值决定模糊的方向和大小

### 优化

- ![渲染优化](/img/note/2022-05-03-20-13-40.png)

### 设计模式-优化型

> [优化型模式 - 浅墨](https://github.com/QianMo/Game-Programmer-Study-Notes/blob/master/Content/%E3%80%8A%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/README.md)感觉优化型的设计模式的思想有一种通用性，所以优先弄明白，在面试时候就有问到开放题可以使用其中思想优化（有次现场想了个很nice的算法呀，延迟数组的删除操作替换成脏标记，等到一定时机整理一遍，有垃圾回收算法的感觉在里面了，但是那次面试官很敷衍，好像get不到）

- `数据局部性模式 Data Locality`，通过保证处理的数据排列在连续内存上，以提高内存局部性，从而提高性能
- `脏标识模式 Dirty Flag`，使用脏标记来判断是否需要重新计算
- `对象池模式 Object Pool`，顾名思义
- `空间分区模式Spatial Partition`，将对象存储在基于位置组织的数据结构中，来有效的定位对象
