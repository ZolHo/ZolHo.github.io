---
layout: post
title: "笔记 - 知识点笔记-22年5月"
subtitle: ''
author: "ZolHo"
header-style: text
tags:
  - 学习记录
---

- 左右手坐标系下的默认旋转方向原来是不同的？？左手系顺时针，右手逆时针。(US入门精要4.2.5节)
- 半兰伯特模型：兰伯特模型中的点乘结果偏移+0.5，让非光线直射处也亮
- Schlick菲涅尔近似等式：$F_{schlick}(\bold{v,n})=F_0+(1-F_0)(1-\bold{v}\cdot \bold{n})^5$
- Empricial菲涅尔近似等式：$F_{Empricial}(\bold{v,n}=\max(0,\min(1,bias+scale\times (1-\bold{v}\cdot \bold{n})^{power})))$
  
### 法线变换

- 法线变换需要用变换矩阵的**逆转置矩阵**做变换，推导过程如下：![法线变换推导](/img/note/2022-05-03-15-52-00.png)

### 法线贴图

- 模型空间法线贴图优点：
  - 直观，计算简单
  - 边界突变少，边界处可通过插值平滑变化（*待加深理解*）
- 切线空间法线贴图优点：
  - 可换给其他模型使用
  - **可实现UV动画**
  - 纹理对于一个模型内也可重用
  - 可压缩，省略Z坐标

### 其他纹理

- `渐变纹理`，我的理解是将漫反射光照结果映射到我们自定义的纹理上
- `遮罩纹理`，单纯的遮罩纹理就是用于计算时mask其他纹理的某些部分，避免它们加入到计算中

### Bloom效果（后处理）

- 以某个阈值提取出画面中亮的部分做一次模糊，然后与原图混合

### 运动模糊

- 累计缓存：多张图像结果混合（在一帧渲染多次场景）
- 速度缓存：保存之前的渲染结果混合
- 速度映射图：用上一帧的VP矩阵对这一帧的顶点做变换，与本次变换结果做插值即可得到速度映射图。然后用速度值决定模糊的方向和大小

### 优化

- ![渲染优化](/img/note/2022-05-03-20-13-40.png)

### 设计模式-优化型

> [优化型模式 - 浅墨](https://github.com/QianMo/Game-Programmer-Study-Notes/blob/master/Content/%E3%80%8A%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/README.md)感觉优化型的设计模式的思想有一种通用性，所以优先弄明白，在面试时候就有问到开放题可以使用其中思想优化（有次现场想了个很nice的算法呀，延迟数组的删除操作替换成脏标记，等到一定时机整理一遍，有垃圾回收算法的感觉在里面了，但是那次面试官很敷衍，好像get不到）

- `数据局部性模式 Data Locality`，通过保证处理的数据排列在连续内存上，以提高内存局部性，从而提高性能
- `脏标识模式 Dirty Flag`，使用脏标记来判断是否需要重新计算
- `对象池模式 Object Pool`，顾名思义
- `空间分区模式Spatial Partition`，将对象存储在基于位置组织的数据结构中，来有效的定位对象

### 求凸包算法

> [凸包 —— 五种解法](https://blog.csdn.net/lxt_Lucia/article/details/83116517)

- `分治法`：每次寻找将点集划分为上下包，上包再上没有点则这部分以及找到，反之找下包。具体算法如图![凸包-分治法](/img/note/2022-05-04-21-27-11.png)
- `Jarvis步进法`：从最下方的点开始，以每个其他点和它的连线的夹角为条件，找出最下夹角作为下一个凸包点。![凸包-Jarvis步进法](/img/note/2022-05-04-21-34-01.png)
- [ ] `Melkman算法`，待深入学习

### BVH树构建

> [BVH with SAH](https://www.cnblogs.com/lookof/p/3546320.html)

二叉树，叶子节点存储物体，中间节点存储包围盒，用递归的方式自底向上组织，需要的数据是全部物体的list，下面需要确定list中物品的排序和划分算法：

1. 决定在xyz哪一条轴上进行划分，优先在物体分散的轴
2. `SAH`表面积启发式算法（Surface Area Heuristic）决定划分方式：假设在list中切一刀，划分成A、B两个包围盒，那么可以通过最小化损失函数的思想来优化AB的划分。在SAH算法中表现为最小化AB包围盒的面积差

### 两直线求最短距离

> [空间两条直线的最短距离及最近点计算](https://blog.csdn.net/Hunter_pcx/article/details/78577202)

推导看懂了，但是怎么解释呢？待

### PCF和PCSS

`PCF`, percentage closer filter, 用于生成软阴影。思路是用采样点在光源空间的深度，和采样点**周围**的shadow map储存的深度都做一次比较，将比较结果(1 or 0)平均或加权平均，就可以得到[0, 1]之间的软阴影。

`PCSS`, percentage closer soft shadows, 在PCF的基础上生成更真实的软阴影。对于PCF中的**周围**，即filter的大小，有越大越软这样的关系。而一个采样点的阴影到底要多软，实际上与*光源->遮挡物边缘->阴影* 这三者距离比值有关，简单来说就是遮挡物离光源越近，那么对应的半影面积越大，即阴影越软。所以我们动态调整fiter的大小，从而生成更符合物理世界效果的阴影。要实现PCSS主要有以下三步：

1. 以一定范围内的遮挡距离（即shadow map的值）平均得到一个**平均遮挡距离**。这里的实现方式待深入，理论上是以光源照射到采样点的过程中投影到shadow map上的那一部分
2. 以**平均遮挡距离**计算**filter大小**
3. 以**filter大小**进行**PCF**计算软阴影
